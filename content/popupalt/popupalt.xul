<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Popup ALT Attribute.
   -
   - The Initial Developer of the Original Code is SHIMODA Hiroshi.
   - Portions created by the Initial Developer are Copyright (C) 2002-2009
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s): SHIMODA Hiroshi <piro@p.club.ne.jp>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<?xml-stylesheet href="chrome://popupalt/content/tooltip.css" type="text/css"?>

<overlay xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<script type="application/x-javascript"><![CDATA[

// Popup ALT attributes of IMG (or other) elements
var initPopupALTDone = false;
function initPopupALT() {
	if (initPopupALTDone) return;

	initPopupALTDone = true;

	var originalFillInHTMLTooltip;

	var pref = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefService).getBranch(null);
	var nsISupportsString = Components.interfaces.nsISupportsString;

	try {
		const kMULTILINE = 'popupalt-multiline-enabled';

		const XULAppInfo = Components.classes['@mozilla.org/xre/app-info;1']
				.getService(Components.interfaces.nsIXULAppInfo);
		var version = XULAppInfo.platformVersion.split('.');
		if (parseInt(version[0]) >= 2 || parseInt(version[1]) >= 9) {
			document.documentElement.removeAttribute(kMULTILINE);
		}
		else {
			document.documentElement.setAttribute(kMULTILINE, true);
		}
	}
	catch(e) {
	}


	var findParentNodeByAttr = function(aNode, aAttr, aValue) {
		if (!aNode) return null;

		if (!aNode.ownerDocument ||
			aNode.ownerDocument == document ||
			aNode.parentNode == aNode.ownerDocument.documentElement)
			return null;

		if (
			aNode.nodeType == Node.ELEMENT_NODE &&
			aNode.hasAttribute(aAttr) &&
			(aValue == '*' || aNode.getAttribute(aAttr) == aValue)
			)
			return aNode;

		return findParentNodeByAttr(aNode.parentNode, aAttr, aValue);
	}

	var findParentNodesByAttr = function(aNode, aAttr, aValue) {
		if (!aNode) return [];

		if (!aNode.ownerDocument ||
			aNode.ownerDocument == document ||
			aNode.parentNode == aNode.ownerDocument.documentElement)
			return [];

		var ret = [];
		if (
			aNode.nodeType == Node.ELEMENT_NODE &&
			aNode.hasAttribute(aAttr) &&
			(aValue == '*' || aNode.getAttribute(aAttr) == aValue)
			)
			ret.push(aNode);

		return ret.concat(findParentNodesByAttr(aNode.parentNode, aAttr, aValue));
	}


	var newFillInHTMLTooltip = function(elem)
	{
		try {
			// "replaceMe" is for NS6.2.3
			var tooltipNode = document.getElementById('aHTMLTooltip') || document.getElementById('replaceMe');

			var tooltiptext;

			if (elem) {
				var target = elem;
				while (
					target &&
					(
						target.nodeType != Node.ELEMENT_NODE ||
						!target.attributes.length
					)
					)
					target = target.parentNode;

				if (target) {

					var attrlist = null;
					try {
						attrlist = pref.getBoolPref('browser.chrome.tooltips.attrlist.enabled') ? pref.getComplexValue('browser.chrome.tooltips.attrlist', nsISupportsString).data : null ;
					}
					catch(ex) {
	//					dump(ex);
					}

					if (attrlist) {
						var i, j;

						attrlist = attrlist.split('|');
						var recursive ;
						try {
							recursive = pref.getBoolPref('browser.chrome.tooltips.attrlist.recursively');
						}
						catch(e) {
						}
						var foundList = {};
						var nodes;

						for (i in attrlist) {
							if (!attrlist[i]) continue;

							nodes = findParentNodesByAttr(target, attrlist[i], '*');
							if (!nodes.length) continue;

							for (j in nodes) {
								if (!nodes[j]) continue;

								if (!nodes[j].getAttribute(attrlist[i]))
									continue;

								if (!(nodes[j].nodeName in foundList))
									foundList[nodes[j].nodeName] = {
										_node : nodes[j]
									};

								foundList[nodes[j].nodeName][attrlist[i]] = nodes[j].getAttribute(attrlist[i]);

								if (!recursive) break;
							}
						}

						var leaf;
						var list = [];
						for (i in foundList) {
							leaf = ['< '+i+' >'];
							for (j in foundList[i])
								if (j != '_node')
									leaf.push('  '+j+' : '+foundList[i][j]);

							list.push({
								node : foundList[i]._node,
								text : leaf.join('\n')
							});
						}
						tooltiptext = [];
						if (list.length) {
							list.sort(function(aA, aB) {
								return aA.node.compareDocumentPosition(aB.node) & Node.DOCUMENT_POSITION_FOLLOWING) ? 1 : -1 ;
							});

							for (i in list)
								tooltiptext.push(list[i].text);
						}
						tooltiptext = tooltiptext.length ? tooltiptext.join('\n') : null ;

						delete foundList;
					}
					else if (
						target.ownerDocument.contentType.indexOf('image') != 0 &&
						target.localName.toLowerCase() == 'img' &&
						target.alt &&
						!target.title
						) {
						tooltiptext = [];
						if (!findParentNodeByAttr(target, 'title', '*'))
							tooltiptext.push(String(target.alt));

						tooltiptext = tooltiptext.length ? tooltiptext.join('\n').replace(/\r\n/g, '\n') : null ;
					}
				}

				if (tooltiptext) {
					// hack for Google Toolbar
					tooltipNode.isGoogleTooltip = false;

					tooltipNode.removeAttribute('label');
					tooltipNode.setAttribute('label', tooltiptext);
					return true;
				}
			}
		}
		catch(e) {
		}

		return window.originalFillInHTMLTooltip(elem);
	};

	if ('GTB_Tooltip' in window) { // hack for Google Toolbar
		window.originalFillInHTMLTooltip = function(aElement) {
			return GTB_GoogleToolbarOverlay.tooltip.__popupalt__maybeShowTooltip(aElement);
		}
		GTB_Tooltip.prototype.__popupalt__maybeShowTooltip = GTB_Tooltip.prototype.maybeShowTooltip;
		GTB_Tooltip.prototype.maybeShowTooltip = newFillInHTMLTooltip;
	}
	else {
		window.originalFillInHTMLTooltip = window.FillInHTMLTooltip;
		window.FillInHTMLTooltip  = newFillInHTMLTooltip;
	}

	var tooltipNode = document.getElementById('aHTMLTooltip') || document.getElementById('replaceMe');
	if ('clear' in tooltipNode) tooltipNode.clear();
}

window.addEventListener('load', initPopupALT, false);
window.addEventListener('load', initPopupALT, false);

]]></script>

</overlay>
